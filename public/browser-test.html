<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>ğŸ¦· Dentist IVR â€” Browser Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f8f8f8;
            padding: 20px;
        }
        
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        #log {
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-line;
        }
    </style>
</head>

<body>
    <h2>ğŸ¦· Dentist IVR â€” Browser Test</h2>
    <button id="callBtn" disabled>ğŸ“ Call IVR</button>
    <button id="hangupBtn" disabled>âŒ Hang Up</button>
    <div id="log"></div>

    <script>
        const logDiv = document.getElementById("log");
        const log = (msg) => {
            const t = new Date().toLocaleTimeString();
            logDiv.textContent += `[${t}] ${msg}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        };

        let device, call;

        // Diagnostics hooks
        window.onerror = function(msg, url, line, col, error) {
            log(`ğŸ window.onerror: ${msg} at ${url}:${line}:${col}`);
            if (error && error.stack) log(error.stack);
        };
        window.onunhandledrejection = function(e) {
            log(`ğŸ unhandledrejection: ${e.reason && e.reason.message ? e.reason.message : e.reason}`);
        };
        (function envLogs() {
            try {
                log(`ğŸŒ Location: ${location.href}`);
                log(`ğŸ”’ Protocol: ${location.protocol}`);
                log(`ğŸ§­ Referrer: ${document.referrer || "-"}`);
                log(`ğŸ§© UA: ${navigator.userAgent}`);
                if (navigator.connection) {
                    const nc = navigator.connection;
                    log(`ğŸ“¶ Net: type=${nc.effectiveType}, downlink=${nc.downlink}Mb, rtt=${nc.rtt}ms, saveData=${nc.saveData}`);
                }
            } catch (_) {}
        })();

        async function probeCdn(url) {
            try {
                const res = await fetch(url, {
                    method: "GET",
                    mode: "no-cors"
                });
                // With no-cors we can't read details, but we can still know it didn't throw
                log(`ğŸ” probe(no-cors) ${url} => ok (opaque)`);
            } catch (e1) {
                log(`ğŸ” probe(no-cors) ${url} => ERR: ${e1.message}`);
            }
            try {
                const res2 = await fetch(url, {
                    method: "GET"
                });
                log(`ğŸ” probe(cors) ${url} => ${res2.status} ${res2.statusText}`);
                const hdrs = [];
                res2.headers.forEach((v, k) => hdrs.push(`${k}: ${v}`));
                if (hdrs.length) log(`ğŸ” headers:\n${hdrs.join("\n")}`);
            } catch (e2) {
                log(`ğŸ” probe(cors) ${url} => ERR: ${e2.message}`);
            }
        }

        function loadScript(url, opts = {}) {
            return new Promise((resolve) => {
                const s = document.createElement("script");
                s.src = url;
                s.async = true;
                if (opts.crossOrigin !== false) s.crossOrigin = "anonymous";
                if (opts.referrerPolicy) s.referrerPolicy = opts.referrerPolicy;
                s.onload = () => resolve({
                    ok: true
                });
                s.onerror = (e) => {
                    log(`âŒ script onerror for ${url}`);
                    resolve({
                        ok: false,
                        error: e
                    });
                };
                document.head.appendChild(s);
            });
        }

        async function loadTwilioSdk() {
            const sources = [{
                label: "primary",
                url: "https://sdk.twilio.com/js/voice/releases/2.7.3/twilio.min.js"
            }, {
                label: "cdn-fallback",
                url: "https://media.twiliocdn.com/sdk/js/voice/releases/2.7.3/twilio.min.js"
            }, {
                label: "local",
                url: "/vendor/twilio-voice-sdk-2.7.3.min.js",
                local: true
            }];
            const ready = () => (typeof Twilio !== "undefined" && Twilio.Device);
            if (ready()) return true;

            for (const src of sources) {
                log(`â¬‡ï¸ loading SDK (${src.label}): ${src.url}`);
                if (src.local) {
                    try {
                        const res = await fetch(src.url, {
                            method: "GET"
                        });
                        log(`ğŸ” probe(local) ${src.url} => ${res.status} ${res.statusText}`);
                    } catch (e) {
                        log(`ğŸ” probe(local) ${src.url} => ERR: ${e.message}`);
                    }
                } else {
                    await probeCdn(src.url);
                }

                const result = await loadScript(src.url, {
                    crossOrigin: src.local ? false : "anonymous"
                });
                await new Promise((r) => setTimeout(r, 300));

                if (ready()) {
                    log(`âœ… SDK loaded from ${src.label}`);
                    return true;
                }

                log(`âš ï¸ ${src.label} load result: ${result.ok ? "ok" : "error"}`);
            }

            return ready();
        }

        async function initTwilio() {
            try {
                const sdkOk = await loadTwilioSdk();
                if (!sdkOk || typeof Twilio === "undefined" || !Twilio.Device) {
                    log("âŒ SDK failed to load from both CDNs. Check network/adblock.");
                    return;
                }
                log("ğŸ”— Fetching Twilio access token...");
                const res = await fetch("/api/token");
                const {
                    token
                } = await res.json();
                if (!token) throw new Error("No token returned from /api/token");

                log("âœ… Token received. Initializing Twilio Device v2...");
                device = new Twilio.Device(token, {
                    codecPreferences: ["opus", "pcmu"],
                    fakeLocalDTMF: true,
                    enableRingingState: true,
                });

                device.on("registered", () => {
                    log("ğŸ§ Device registered â€” you can now call the IVR.");
                    document.getElementById("callBtn").disabled = false;
                });

                device.on("unregistered", () => {
                    log("â„¹ï¸ Device unregistered.");
                    document.getElementById("callBtn").disabled = true;
                });

                device.on("error", (err) => log(`âš ï¸ Device error: ${err.message}`));
                device.on("disconnect", () => {
                    log("ğŸ“´ Call disconnected.");
                    document.getElementById("hangupBtn").disabled = true;
                    document.getElementById("callBtn").disabled = false;
                });

                device.register();
            } catch (err) {
                log("âŒ Initialization error: " + err.message);
            }
        }

        // Simple DTMF keypad UI
        const keypad = document.createElement("div");
        keypad.style.marginTop = "10px";
        keypad.style.display = "grid";
        keypad.style.gridTemplateColumns = "repeat(3, 60px)";
        keypad.style.gap = "8px";
        const keys = ["1","2","3","4","5","6","7","8","9","*","0","#"];
        keys.forEach(k => {
            const b = document.createElement("button");
            b.textContent = k;
            b.onclick = () => {
                if (!call) return log("âš ï¸ No active call to send DTMF.");
                try { call.sendDigits(k); log(`ğŸ“Ÿ DTMF sent: ${k}`); } catch (e) { log(`âŒ DTMF error: ${e.message}`); }
            };
            keypad.appendChild(b);
        });
        document.body.insertBefore(keypad, document.getElementById("log"));

        document.getElementById("callBtn").onclick = async () => {
            try {
                if (!device) return log("âš ï¸ Device not ready yet!");
                log("ğŸ“ Connecting to Dentist IVR...");
                call = await device.connect();
                document.getElementById("callBtn").disabled = true;
                document.getElementById("hangupBtn").disabled = false;
                call.on("accept", () => log("âœ… Call connected â€” speak freely."));
                call.on("error", (err) => log("âŒ Call error: " + err.message));
                call.on("disconnect", () => log("ğŸ“´ Call ended."));
            } catch (e) {
                log("âŒ Connect error: " + e.message);
            }
        };

        document.getElementById("hangupBtn").onclick = () => {
            if (call) call.disconnect();
            log("ğŸ›‘ Hangup requested by user.");
            document.getElementById("hangupBtn").disabled = true;
            document.getElementById("callBtn").disabled = false;
        };

        // init Twilio as soon as page loads
        initTwilio();
    </script>
</body>

</html>